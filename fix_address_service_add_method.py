from pathlib import Path

path = Path('src/modules/users/application/services/address-management.service.ts')
text = path.read_text()

insertion_point = "  async bulkUpdateAddresses(userId: string, addressIds: string[], updateData: Partial<UpdateAddressRequest>): Promise<number> {\n    if (!addressIds || addressIds.length === 0) {\n      return 0;\n    }\n\n    // TODO: enforce ownership by userId when repository supports scoped updates\n    return await this.addressRepository.bulkUpdate(addressIds, updateData);\n  }\n\n"

if insertion_point not in text:
    raise SystemExit('bulkUpdateAddresses block not found for insertion')

new_method = "  async searchUserAddresses(\n    userId: string,\n    searchDto: SearchAddressesDto\n  ): Promise<{\n    addresses: AddressEntity[];\n    total: number;\n    page: number;\n    limit: number;\n    totalPages: number;\n    hasNext: boolean;\n    hasPrev: boolean;\n  }> {\n    const page = searchDto.page ?? 1;\n    const limit = searchDto.limit ?? 10;\n    const skip = (page - 1) * limit;\n\n    const matchesFilters = (address: AddressEntity): boolean => {\n      if (searchDto.type && address.type !== searchDto.type) {\n        return false;\n      }\n      if (typeof searchDto.isDefault === 'boolean' && address.isDefault !== searchDto.isDefault) {\n        return false;\n      }\n      if (typeof searchDto.isActive === 'boolean' && address.isActive !== searchDto.isActive) {\n        return false;\n      }\n      if (searchDto.city && address.city.toLowerCase() !== searchDto.city.toLowerCase()) {\n        return false;\n      }\n      if (searchDto.state && address.state.toLowerCase() !== searchDto.state.toLowerCase()) {\n        return false;\n      }\n      if (searchDto.country && address.country.toLowerCase() !== searchDto.country.toLowerCase()) {\n        return false;\n      }\n      if (searchDto.postalCode && address.postalCode.toLowerCase() !== searchDto.postalCode.toLowerCase()) {\n        return false;\n      }\n      return true;\n    };\n\n    let addresses: AddressEntity[] = [];\n    let total = 0;\n\n    if (searchDto.query) {\n      const queryResults = await this.addressRepository.searchByUser(userId, searchDto.query);\n      const filtered = queryResults.filter(matchesFilters);\n\n      const sortField = searchDto.sortBy ?? 'createdAt';\n      const sortDirection = searchDto.sortOrder ?? 'desc';\n      filtered.sort((a, b) => {\n        const aValue = (a as any)[sortField] ?? (a as any)[sortField.charAt(0).toLowerCase() + sortField.slice(1)];\n        const bValue = (b as any)[sortField] ?? (b as any)[sortField.charAt(0).toLowerCase() + sortField.slice(1)];\n\n        if (aValue === undefined || bValue === undefined) {\n          return 0;\n        }\n\n        if (aValue instanceof Date && bValue instanceof Date) {\n          return sortDirection === 'asc' ? aValue.getTime() - bValue.getTime() : bValue.getTime() - aValue.getTime();\n        }\n\n        if (typeof aValue === 'number' && typeof bValue === 'number') {\n          return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;\n        }\n\n        const aStr = String(aValue).toLowerCase();\n        const bStr = String(bValue).toLowerCase();\n        return sortDirection === 'asc' ? aStr.localeCompare(bStr) : bStr.localeCompare(aStr);\n      });\n\n      total = filtered.length;\n      addresses = filtered.slice(skip, skip + limit);\n    } else {\n      const where: any = { userId };\n      if (searchDto.type) where.type = searchDto.type;\n      if (typeof searchDto.isDefault === 'boolean') where.isDefault = searchDto.isDefault;\n      if (typeof searchDto.isActive === 'boolean') where.isActive = searchDto.isActive;\n      if (searchDto.city) where.city = searchDto.city;\n      if (searchDto.state) where.state = searchDto.state;\n      if (searchDto.country) where.country = searchDto.country;\n      if (searchDto.postalCode) where.postalCode = searchDto.postalCode;\n\n      const orderBy = searchDto.sortBy ? { field: searchDto.sortBy, direction: searchDto.sortOrder ?? 'desc' } : undefined;\n\n      [addresses, total] = await Promise.all([\n        this.addressRepository.findMany({\n          skip,\n          take: limit,\n          where,\n          orderBy,\n        }),\n        this.addressRepository.count(where),\n      ]);\n    }\n\n    const totalPages = Math.max(1, Math.ceil(total / limit));\n    return {\n      addresses,\n      total,\n      page,\n      limit,\n      totalPages,\n      hasNext: page < totalPages,\n      hasPrev: page > 1,\n    };\n  }\n\n"

text = text.replace(insertion_point, insertion_point + new_method)
path.write_text(text)
